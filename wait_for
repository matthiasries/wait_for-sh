#!/bin/bash

host="127.0.0.1"
port=22
delay=0
proto="tcp"
sleep_time=1
connection_timeout=5
timeout=300
timeouted=0
cmd=""
go=0
start_time=$(date +%s)

die(){
	local code=$1
	shift
	echo "$@"
	exit $code
}

usage(){
	cat <<EOF
NAME
	wait_for - wait_for a host to be reachable


SYNOPSIS

	wait_for [--option=value] [command]


DESCRIPTION

		this command waits for a host:port to be reachable. It either executes a command directly or if no command is given it returns 0 or an error code. 
		the first non option argument is recognized as the beginning of the command. The command has to go last.
		wait_for needs at least 1 argument. Either --host or a command.

OPTIONS

		--host=127.0.0.1   # A resolvable hostname or IP address to wait for Default is 127.0.0.1
		--help             # Shows this help page
		--sleep=1          # Number of seconds to sleep between checks. Default 1 seconds
		--delay=0          # Number of seconds to wait before starting to poll. Default 0 seconds
		--wait=0           # Number of seconds to wait after the host is reachable. Default  0 seconds
		--timeout=300      # Maximum number of seconds to wait for, when used with another condition it will force an error. Default 300 seconds
		--port=22          # Port number to poll Default is 22 (ssh)

COMMAND
		every non option argument is considered as beginning of the command wait_for is supposed to execute.
		if no command is given wait_for returns an exit status code.


EXAMPLES
		wait_for --host=myserver scp file  root@myserver:/folder/  || echo "Timeout. myserver not reachable"
		wait_for --host=myserver ssh myserver reboot && echo "myserver is rebooting"
		wait_for --host=myserver --port=80  &&  curl --HEAD myserver  || echo "My Server not reachable" 
		wait_for --sleep=5

		if wait_for --host=mad4milk.de;
		then
			scp stuff 
			ssh "do stuff"
			do more stuff
		else
			echo "can't do stuff"
		fi	

EXIT STATUS
		wait_for exits with 
			0 on success
			84 on connect timeout
			92 invalid argument
		or the return code of "command"

EOF
}

until [[ "$@" == '' ]]
do
	param="${1//=*/}"
	value="${1//*=/}"
	case $param in
		--help)
			usage
			exit 1
			;;
		--host)
                        [[ "$value" == '' ]] && die 92 "--host has to be an IP or hostname"
                        go=1
                        host="$value"
                        ;;
                --port)
                        [[ "${value//[0-9a-zA-Z]/}" == '' ]] || die 92 "--port accepts a port number or a registered service name"
                        port="$value"
                        go=1
                        ;;
		--delay)
                        [[ "${value//[0-9]/}" == '' ]] || die 92 "--delay only accepts seconds"
                        delay="$value"
                        ;;
		--sleep)
			[[ "${value//[0-9]/}" == '' ]] || die 92 "--sleep only accepts seconds"
			sleep="$value"
			;;
		--timeout)
			[[ "${value//[0-9]/}" == '' ]] || die 92 "--timeout only accepts seconds"
			timeout="$value"
			;;
		--proto)
			[[ "${value}" != 'tcp' && "${value}" != "udp" ]] || die 92 "--proto only accepts tcp or udp as a parameter"
			proto="$value"
			;;
		*)
			cmd="$@"
			go=1
			break
			;;
	esac
	shift
done

real_timeout=$((delay+timeout))

check_timeout(){
	if [[ $(($(date +%s)-start_time)) -gt $real_timeout ]];
	then
		timeouted=1
		return 0
	fi
	return 1
}


if [[ $go -eq 1 ]]; 
then
	sleep "$delay"
	until check_timeout
	do
		(echo -n "" > "/dev/$proto/$host/$port") >/dev/null 2>&1 && break
		sleep $sleep_time
	done
	[[ $timeouted != 0 ]] && exit 84 
	[[ "$cmd" == "" ]] && exit 0
	[[ "$cmd" != "" ]] && eval "$@"
fi	
exit $status
